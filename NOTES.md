# A quick and dirty MailGun clone in Elixir


## SMTP

[SMTP](http://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol) is 8yrs older than me (the first RFC was in 1982). The API is simple:

* The program that handles the SMTP messages listens to a port.
* When the client is making a request to an SMTP server, the server maintains a session. Just like what a web browser does for a user today.
* The API request (what we could call it today) is made by sending a message with an SMTP verb following by data. Each request ends with a line break.
* The SMTP server _usually_ responds with a message that starts with an SMTP code followed by the message.

A typical request-response might look like the following:

```
DUDE whats up
200 I am fine
```

I made up that request-response. `DUDE` is not an SMTP verb. But there are many others like `HELO`, `RCPT`, `DATA`, etc.

> I apologize if I've convinced you that SMTP is very simple. There's much more to it. And our fellow humans have done great work to extend it by building stuff for it or on top of it. You can read more [here](http://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol#Related_Requests_For_Comments).


## Email as an API

SMTP is one of the oldest APIs. It has a very large user base and it still works. Want to share news about your new born? Shares sales report with your team? Invite people to a party?

Email works. What more? If you accept incoming mail from your users, it comes with free authentication :)

Sadly, setting up an SMTP server to handle incoming email still needs a great [bullet-proof guide](http://iafonov.github.io/blog/hardcore-email-infrastructure-setup.html). There are services like [MailGun](http://mailgun.com), [Postmark](http://postmarkapp.com), etc, that make it easier for developers to handle incoming mail for apps. They receive incoming mail on your behalf and POST them as JSON to your app.


## Building an SMTP server in Elixir

Since I started working on Erlang (and later on Elixir), I've been curious to try handling incoming mail with it. I've always believed that the nature of the language and the primitives that OTP provides makes it easy to build applications that can accept and process incoming mail. My luck turned gold when I hit upon an SMTP server example, within the source code of an Erlang library called [gen_smtp](https://github.com/Vagabond/gen_smtp/blob/master/src/smtp_server_example.erl).

I'll try and walk you through some code to understand (sufficiently) and hack it up to get a quick and dirty mail-to-json API up and running.


## Generating a new Elixir mix project

At this point, I'll assume you have Elixir v1.0.1 installed, to be able to generate a new project using mix

```
mix new mail_to_json --sup
```

## mix.exs

In your project's `mix.exs` file add the following libraries as dependencies:

* `gen_smtp` - (Erlang SMTP library
* `poison` - pure Elixir JSON parser
* `httpoison` - HTTP client for Elixir

Your `deps/0` function in mix.exs should look like the following:

```
defp deps do
  [
    {:gen_smtp,  github: "Vagabond/gen_smtp"},
    {:poison,    github: "devinus/poison"},
    {:httpoison, github: "edgurgel/httpoison"}
  ]
end
```

The setup for `httpoison`, requires that it be added to the application start list. This is to ensure that it is started and ready for our application to use.

```
def application do
  [applications: [:logger, :httpoison],
   mod: {MailToJson, []}]
end
```

## Fetch dependencies

Fetch the dependencies by running the following command in your console

```
mix deps.get
```

## Facilitate configuration options

Let's setup some options that can be configured in the app. Put this in your `config/config.exs`

```
use Mix.Config

# This is where you want the JSON of the mail to be posted to
config :mail_to_json, :webhook_url, "http://example.com/you/want"

# The SMTP port to which we want our application to listen to
config :mail_to_json, :smtp_port, 2525
```

We are now ready to add nut and bolts to get our stuff running


## The app

### lib/mail_to_json.ex

Most of this file is pretty standard generated by `mix` when you create the project. To the list of `children`, we add our `MailToJson.SmtpServer` module to be started as a worker.

The following line...

```
children = []
```

becomes...

```
children = [
  worker(MailToJson.SmtpServer, [], restart: :transient)
]
```


### lib/mail_to_json/smtp_server.ex

`MailToJson.SmtpServer` being added as a worker in the above file means the `start_link/0` function will be called. It will also expect that the return value of the function is a pid.

The `start_link/0` function wraps `:gen_smtp_server.start/2`, so that it can be supervised. We pick the SMTP port to listen to from the application configuration. (remember the `config/config.exs`?).

For now we assume that `MailToJson.SmtpHandler` is the module that handles the SMTP callbacks that `:gen_smtp_server` requires.

```
defmodule MailToJson.SmtpServer do

  def start_link do
    session_options = [ callbackoptions: [parse: true] ]
    :gen_smtp_server.start(MailToJson.SmtpHandler, [[port: smtp_port, sessionoptions: session_options]])
  end


  defp smtp_port do
    Application.get_env :mail_to_json, :smtp_port
  end
end
```

### lib/mail_to_json/smtp_handler/state.ex

We'll need a struct to pass state through functions. For now we'll define an options field.

```
defmodule MailToJson.SmtpHandler.State do
  defstruct options: []
end
```

### lib/mail_to_json/smtp_handler.ex

`MailToJson.SmtpHandler` module is pretty large but it is simple. We have certain module attributes in order to make error codes readable.


#### init/4

This function is called by `gen_smtp` when a new mail arrives. It initializes a new session to serve the client. It is passed the following arguments:

* hostname - the SMTP server's hostname
* session_count - number of mails currently being handled. We can then choose to reject the current mail session based on this.
* client_ip_address - IP address of the client
* options - the `callbackoptions` passed to `:gen_smtp_server.start/2`

The return value should be the banner that is shown to the client. This is sort of the welcome banner. You can display anything you want.

```
def init(hostname, _session_count, _client_ip_address, options) do
  banner = [hostname, " ESMTP mail-to-json server"]
  state  = %State{options: options}
  {:ok, banner, state}
end
```

#### handle_HELO/2

As soon as the client successfully connects. It sends a HELO message. This function handles the HELO message. We just reply with our response.

```
def handle_HELO(hostname, state) do
  # This is how we respond to the client
  :io.format("#{@smtp_requested_action_okay} HELO from #{hostname}~n")

  # We return the max size of the mail the that we will allow the client to send
  {:ok, 10 * 1024, state}
end
```

#### handle_EHLO/2

This is basically like a patch over the older HELO. It allows servers to respond with the ESMTP extensions that the SMTP server supports.

```
def handle_EHLO(_hostname, extensions, state) do
  supported_extensions = case (state.options[:auth] || false) do
    true ->
      extensions ++ [{"AUTH", "PLAIN LOGIN CRAM-MD5"}, {"STARTTLS", true}]
    false ->
      extensions
  end
  {:ok, supported_extensions, state}
end
```

#### handle_MAIL/2

Accept or reject mail from addresses here. We'll allow all senders to send us mail.

```
def handle_MAIL(sender, state) do
  {:ok, state}
end
```

#### handle_VRFY/2

Accept mail only for the accounts that exist in the system. We'll just say that all accounts are valid.

```
def handle_VRFY(user, state) do
  {:ok, "#{user}@#{:smtp_util.guess_FQDN()}", state}
end
```

#### handle_RCPT/2

Responds to the client with a receipt that the mail to the recipient was received and handled. We'll

```
def handle_RCPT(to, state) do
  {:ok, state}
end
```

#### handle_


## References

* SMTP commands - <http://the-welters.com/professional/smtp.html>
* SMTP error codes - <http://www.greenend.org.uk/rjk/tech/smtpreplies.html>
